"use strict";

///////////////////////////////////////
// Modal window
const header = document.querySelector(".header");
const modal = document.querySelector(".modal");
const overlay = document.querySelector(".overlay");
const btnCloseModal = document.querySelector(".btn--close-modal");
const btnsOpenModal = document.querySelectorAll(".btn--show-modal");

const openModal = function (e) {
  e.preventDefault();
  modal.classList.remove("hidden");
  overlay.classList.remove("hidden");
};

const closeModal = function () {
  modal.classList.add("hidden");
  overlay.classList.add("hidden");
};

btnsOpenModal.forEach((btn) => btn.addEventListener("click", openModal));

btnCloseModal.addEventListener("click", closeModal);
overlay.addEventListener("click", closeModal);

document.addEventListener("keydown", function (e) {
  if (e.key === "Escape" && !modal.classList.contains("hidden")) {
    closeModal();
  }
});

//------------------186---------------//
console.log(document);
console.log(document.documentElement);
console.log(document.head);
console.log(document.body);
const allSection = document.querySelectorAll(".section");
console.log(allSection); // NodeList
console.log(document.getElementById("section--1"));
console.log(document.getElementsByTagName("button")); //HTML collection (life collection)
console.log(document.getElementsByClassName("btn")); //HTML collection (life collection)

const message = document.createElement("div");
message.classList.add("cookie-message");

message.innerHTML =
  'We use cookie <button class="btn btn-close-cookie">Got it!</button>';

//header.prepend(message);
//header.append(message); // preped or append only one work at a time (also used for move elements)
//header.insertAdjacentHTML('beforeend',message.innerHTML);

//for both work do cloning
//header.append(message.cloneNode(true));

// header.before(message);
//header.after(message);

// Delete elements

// document.querySelector('.btn-close-cookie').addEventListener('click',function(){
//   message.remove();
// })

// before remove method came in js
// document.querySelector('.btn-close-cookie').addEventListener('click',function(){
//   message.parentElement.removeChild(message);
// })

//----------------187-------------//
//styles
message.style.backgroundColor = "#37383d";
message.style.width = "120%";

console.log(message.style.height); // nothing printed (we not set it browser set it)
console.log(message.style.width); //120%
//computed by browser
console.log(getComputedStyle(message).height); //43.6667px
console.log(getComputedStyle(message).fontFamily); //Poppins, sans-serif

// message.style.height = `${
//   Number.parseFloat(getComputedStyle(message).height, 10) + 30 + "px"
// }`; // work
message.style.height =
  Number.parseFloat(getComputedStyle(message).height, 10) + 30 + "px"; // work

// set css variable
document.documentElement.style.setProperty("--color-primary", "orangered");

// get Attributes
const logo = document.querySelector(".nav__logo");
console.log(logo.alt); //Bankist logo
console.log(logo.src); //absolute path
console.log(logo.className); //nav__logo
console.log(logo.getAttribute("src")); //img/logo.png (relative path)

//set Attributes
logo.alt = "Beautiful minamalist logo";

//Non-standard
console.log(logo.designer); //undefined (not  standard html attribute)
console.log(logo.getAttribute("designer")); //jonas // now it can accessible
logo.setAttribute("company", "Bankist");

//Data Attributes (use to store data in ui/HTML)

console.log(logo.dataset.versionNumber); //3.0

//-----------188---------------// (make notes)

const btnScrollTo = document.querySelector(".btn--scroll-to");
const section1 = document.querySelector("#section--1");

btnScrollTo.addEventListener("click", function (e) {
  e.preventDefault();
  const slcoords = section1.getBoundingClientRect();
  console.log(slcoords);

  console.log(e.target.getBoundingClientRect()); //getBoundingClientRect is depend on screen viewport size
  console.log("current scroll (X/Y)", window.pageXOffset, window.pageYOffset); // it will give how much scrolling happens
  console.log(
    "height/width of current viewport",
    document.documentElement.clientHeight,
    document.documentElement.clientWidth
  );
  console.log("new");

  //scrolling
  //old approach
  // window.scrollTo(
  //   slcoords.left + window.pageXOffset,
  //   slcoords.top + window.pageYOffset
  // );

  // bit better old approach
  // window.scrollTo({
  //   left: slcoords.left + window.pageXOffset,
  //   top: slcoords.top + window.pageYOffset,
  //   behavior:'smooth',
  // });

  // morden way for morden browser
  section1.scrollIntoView({behavior:'smooth'});
});

//--------------189----------------//
//event is a signal generated by a certain dumb node
// const h1 = document.querySelector('h1');
// h1.addEventListener('mouseenter',function(){
//   alert('Greet you are reading the event!');
// })

// on-event-property (applied directly)(there is an on-event property for all event property) //old method 
// morden way is addEventListener, 2 advantages a) can listen multiple events on a single element b) we can remove event handler if we do not need it any more
// h1.onmouseenter = function(){
//   alert('Listning on-event');
// };

//let suppose we want only one alert
const alerth1 = function(){
  alert('Alert only once');
  //h1.removeEventListener('mouseenter',alerth1); // remove listener
};

const h1 = document.querySelector('h1');
h1.addEventListener('mouseenter',alerth1);

// also can remove after some time has passed
setTimeout(function(){
  h1.removeEventListener('mouseenter',alerth1);
},3000);

//----------190-----------//
//Capturing and Bubbling Phase
/*
when we click on any anchor tag a click event generted inside the root of document node then it passes through every single element node till the target element is not reached
it is called capturing phase then it bubbles up to all parent element not any sibbling element so it act like the the event happened in all its parent element
they listen to events in bubbling phase not capturing.We can do manupulte it for capturing also.all event don't have these cap-bub phases but most have  
*/

//---------------191---------------//
// rgb(255,255,255)

const randomInt = (min,max) =>{
  return Math.floor(Math.random()*(max-min+1)+min)
} 

const randomColor=()=> `rgb(${randomInt(0,255)},${randomInt(0,255)},${randomInt(0,255)})`;
console.log(randomColor());

document.querySelector('.nav__link').addEventListener('click',function(e){
  this.style.backgroundColor = randomColor();
  console.log('Link',e.target,e.currentTarget) // e.target-->it will give where the event happen not where the event handeler attached i.e, <a class='nav__link'></a> where the click first happens. e.currentTarget ---> its gives the place where the event handeler is actually attached
  console.log(e.currentTarget === this);
  // stop propagation (can be used but not recomended for use generally)
  e.stopPropagation(); // only work for first link because querySelector used
});
document.querySelector('.nav__links').addEventListener('click',function(e){
  this.style.backgroundColor = randomColor();
  console.log('Container',e.target,e.currentTarget) // e.target-->it will give where the event happen not where the event handeler attached i.e, <a class='nav__link'></a> where the click first happens. e.currentTarget ---> its gives the place where the event handeler is actually attached i.e, <ul></ul>
  console.log(e.currentTarget === this);
},true);
document.querySelector('.nav').addEventListener('click',function(e){
  this.style.backgroundColor = randomColor();
  console.log('nav',e.target,e.currentTarget) // e.target-->it will give where the event happen not where the event handeler attached i.e, <a class='nav__link'></a> where the click first happens. e.currentTarget ---> its gives the place where the event handeler is actually attached
  console.log(e.currentTarget === this); //true
},true); // third parameter true used for --> event handler get captured in bubbling phase(event deligation) if want to be it in capturing phase then // nav will occurs first // by default false

//-------------192----------------//
//Event deligation

//page navigation without event deligation
